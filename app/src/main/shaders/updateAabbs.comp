#version 450
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

struct b3RigidBodyData
{
    vec4 pos;//_m0;
    vec4 quat;//_m1;
    vec4 linVal;//_m2;
    vec4 argVal;
    ivec4 collidableIdx_invMass_restituitionCoeff_frictionCoeff;
};

struct b3RigidBodyDataArg
{
    mat4 pos_quat_lin_arg;
    vec4 collidableIdx_invMass_restituitionCoeff_frictionCoeff;
};

struct aabb//_17
{
    vec4 min;
    vec4 max;
};

layout(set = 0, binding = 0)readonly buffer b3RigidBodyDatas
{
    b3RigidBodyData BodyDatas[];
} RigidBodyDatas;//_37;

layout(set = 0, binding = 1)readonly buffer b3Collidables
{
    ivec4 b3Collidable[];
} Collidables;//_38

layout(set = 0, binding = 1)readonly buffer b3Collidables_f
{
    vec4 b3Collidable[];
} Collidables_f;//_381;

layout(set = 0, binding = 2)readonly buffer b3ShapeAabb
{
    aabb bb[];
} localShapeAABB;//_39

layout(set = 0, binding = 3) buffer B3Aabb
{
    aabb bb[];
} AABB;//_40

struct ioInfo
{
    vec4 point;
};

struct cmdInfo{
    uint vetCont;
    uint insCont;
    uint vetOff;
    uint insOff;
};

layout(set = 0,binding = 4) writeonly buffer outPos { ioInfo outinfo[]; };

layout(set = 0,binding = 5) writeonly buffer outCmd { cmdInfo cmdinfo[]; };

layout(set = 0,binding = 6) writeonly buffer outPosCube { ioInfo outCubeinfo[];};

layout(set = 0,binding = 7) writeonly buffer outCmdCube { cmdInfo cmdCubeinfo[];};

layout(push_constant, std430) uniform flags_push
{
    ivec4 fl4;
} flags;

vec3 qtransform( vec4 q, vec3 v ){
    return v + 2.0*cross(q.xyz,cross(q.xyz,v) + q.w*v);
}

void b3ComputeWorldAabb(uint compID)
{
    int shapeIndex = Collidables.b3Collidable[RigidBodyDatas.BodyDatas[compID].collidableIdx_invMass_restituitionCoeff_frictionCoeff[0]][3];
    if (shapeIndex > -1)
    {
        vec4 extent0 = (localShapeAABB.bb[shapeIndex].max - localShapeAABB.bb[shapeIndex].min) * vec4(0.5);
        vec4 center0 = (localShapeAABB.bb[shapeIndex].max + localShapeAABB.bb[shapeIndex].min) * vec4(0.5);
        vec3 center1 = qtransform(RigidBodyDatas.BodyDatas[compID].quat,center0.xyz)+RigidBodyDatas.BodyDatas[compID].pos.xyz;
        vec3 extent1 = qtransform(RigidBodyDatas.BodyDatas[compID].quat,extent0.xyz);


        AABB.bb[compID].min = vec4(center1 - extent1,1.0);
        AABB.bb[compID].max = vec4(center1 + extent1,1.0);
        //AABBArg.bb[compID].min.w=compID;
    }
}


void outAabb(vec3 min,vec3 max,vec4 quat,uint vindex){
    vindex = vindex * 3;

    outinfo[vindex].point=vec4(min,1.0);
    //outinfo[vindex].color=vec4(0.0,1.0,0.0,1.0);

    outinfo[vindex+1].point=vec4(max,1.0);
    //outinfo[vindex+1].color=vec4(1.0,1.0,0.0,1.0);

    outinfo[vindex+2].point=quat;
    if(vindex == 0){
        cmdinfo[0].vetCont=3;
        cmdinfo[0].insCont=1;
        cmdinfo[0].vetOff=0;
        cmdinfo[0].insOff=0;
    }
}

void outAabbCube(vec3 min,vec3 max,vec4 pos,vec4 quat,uint vindex){
    vindex = vindex * 4;
    outCubeinfo[vindex].point=pos;

    outCubeinfo[vindex+1].point=quat;

    outCubeinfo[vindex+2].point=vec4(min,1.0);

    outCubeinfo[vindex+3].point=vec4(max,1.0);
    if(vindex == 0){
        cmdCubeinfo[0].vetCont=4;
        cmdCubeinfo[0].insCont=1;
        cmdCubeinfo[0].vetOff=0;
        cmdCubeinfo[0].insOff=0;
    }
}
void main()
{
    b3ComputeWorldAabb(gl_GlobalInvocationID.x);
    uint vindex = gl_GlobalInvocationID.x;
    vec4 quat = RigidBodyDatas.BodyDatas[vindex].quat;
    vec4 pos = RigidBodyDatas.BodyDatas[vindex].pos;

    vec4 min = localShapeAABB.bb[vindex].min;
    vec4 max = localShapeAABB.bb[vindex].max;
    outAabb(min.xyz,max.xyz,quat,vindex);
    outAabbCube(min.xyz,max.xyz,pos,quat,vindex);

}
