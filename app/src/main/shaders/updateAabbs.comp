#version 450
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

struct b3RigidBodyData
{
    vec4 pos;//_m0;
    vec4 quat;//_m1;
    vec4 linVal;//_m2;
    vec4 argVal;
    ivec4 collidableIdx_invMass_restituitionCoeff_frictionCoeff;
};

struct b3RigidBodyDataArg
{
    mat4 pos_quat_lin_arg;
    vec4 collidableIdx_invMass_restituitionCoeff_frictionCoeff;
};

struct aabb//_17
{
    vec4 min;
    vec4 max;
};

layout(set = 0, binding = 0)readonly buffer b3RigidBodyDatas
{
    b3RigidBodyData BodyDatas[];
} RigidBodyDatas;//_37;

layout(set = 0, binding = 1)readonly buffer b3Collidables
{
    ivec4 b3Collidable[];
} Collidables;//_38

layout(set = 0, binding = 1)readonly buffer b3Collidables_f
{
    vec4 b3Collidable[];
} Collidables_f;//_381;

layout(set = 0, binding = 2)readonly buffer b3ShapeAabb
{
    aabb bb[];
} localShapeAABB;//_39

layout(set = 0, binding = 3)buffer B3Aabb
{
    aabb bb[];
} AABB;//_40

struct ioInfo
{
    vec4 point;
};

struct cmdInfo{
    uint vetCont;
    uint insCont;
    uint vetOff;
    uint insOff;
};

layout(set = 0,binding = 4) writeonly buffer outPos { ioInfo outinfo[]; };

layout(set = 0,binding = 5) writeonly buffer outCmd { cmdInfo cmdinfo[]; };

layout(set = 0,binding = 6) writeonly buffer outPosCube { ioInfo outCubeinfo[];};

layout(set = 0,binding = 7) writeonly buffer outCmdCube { cmdInfo cmdCubeinfo[];};

layout(push_constant, std430) uniform flags_push
{
    ivec4 fl4;
} flags;

vec3 qtransform( vec4 q, vec3 v ){
    return v + 2.0*cross(q.xyz,cross(q.xyz,v) + q.w*v);
}

mat3 QuatGetRotationMatrixABS(vec4 quat)
{
    vec3 quatsq = vec3(quat.x * quat.x, quat.y * quat.y, quat.z * quat.z);
    mat3 quat_mat;

    quat_mat[0].x = 1 - 2 * quatsq.y - 2 * quatsq.z;
    quat_mat[0].y = 2 * quat.x * quat.y - 2 * quat.w * quat.z;
    quat_mat[0].z = 2 * quat.x * quat.z + 2 * quat.w * quat.y;
    //quat_mat[0].w = 0.f;

    quat_mat[1].x = 2 * quat.x * quat.y + 2 * quat.w * quat.z;
    quat_mat[1].y = 1 - 2 * quatsq.x - 2 * quatsq.z;
    quat_mat[1].z = 2 * quat.y * quat.z - 2 * quat.w * quat.x;
    //quat_mat[1].w = 0.f;

    quat_mat[2].x = 2 * quat.x * quat.z - 2 * quat.w * quat.y;
    quat_mat[2].y = 2 * quat.y * quat.z + 2 * quat.w * quat.x;
    quat_mat[2].z = 1 - 2 * quatsq.x - 2 * quatsq.y;
    //quat_mat[2].w = 0.f;

    return mat3(abs(quat_mat[0]),abs(quat_mat[1]),abs(quat_mat[2]));
}

void b3ComputeWorldAabb(uint compID)
{
    int shapeIndex = Collidables.b3Collidable[RigidBodyDatas.BodyDatas[compID].collidableIdx_invMass_restituitionCoeff_frictionCoeff[0]][3];
    if (shapeIndex > -1)
    {
        vec4 extent0 = (localShapeAABB.bb[shapeIndex].max - localShapeAABB.bb[shapeIndex].min) * vec4(0.5);
        vec4 center0 = (localShapeAABB.bb[shapeIndex].max + localShapeAABB.bb[shapeIndex].min) * vec4(0.5);
        vec3 center1 = qtransform(RigidBodyDatas.BodyDatas[compID].quat,center0.xyz)+RigidBodyDatas.BodyDatas[compID].pos.xyz;
        vec3 extent1 = qtransform(RigidBodyDatas.BodyDatas[compID].quat,extent0.xyz);


        AABB.bb[compID].min = vec4(center1 - extent1,1.0);
        AABB.bb[compID].max = vec4(center1 + extent1,1.0);
        //AABBArg.bb[compID].min.w=compID;
    }
}



void outAabb(vec3 min,vec3 max,vec4 quat,uint vindex){
    vindex = vindex * 3;

    outinfo[vindex].point=vec4(min,1.0);
    //outinfo[vindex].color=vec4(0.0,1.0,0.0,1.0);

    outinfo[vindex+1].point=vec4(max,1.0);
    //outinfo[vindex+1].color=vec4(1.0,1.0,0.0,1.0);

    outinfo[vindex+2].point=quat;
    if(vindex == 0){
        cmdinfo[0].vetCont=3;
        cmdinfo[0].insCont=1;
        cmdinfo[0].vetOff=0;
        cmdinfo[0].insOff=0;
    }
}


void computeWorldAabb(vec3 min,vec3 max,vec4 pos,vec4 quat,uint vindex){
    mat3 matQuatABS = QuatGetRotationMatrixABS(quat);
    vec3 center = (max + min)*0.5;
    vec3 extent = (max - min)*0.5;
    vec3 centerAabb=qtransform(quat,center);
    vec3 extentAabb=extent * matQuatABS;//vec3(dot(extent,matQuatABS[0]),dot(extent,matQuatABS[1]),dot(extent,matQuatABS[2]));

    outAabb(centerAabb-extentAabb+pos.xyz,centerAabb+extentAabb+pos.xyz,quat,vindex);
}

void outCube(vec3 min,vec3 max,vec4 pos,vec4 quat,uint vindex){
    vindex = vindex * 4;
    outCubeinfo[vindex].point=pos;
    outCubeinfo[vindex+1].point=quat;
    outCubeinfo[vindex+2].point=vec4(min,1.0);
    outCubeinfo[vindex+3].point=vec4(max,1.0);
    if(vindex == 0){
        cmdCubeinfo[0].vetCont=4;
        cmdCubeinfo[0].insCont=1;
        cmdCubeinfo[0].vetOff=0;
        cmdCubeinfo[0].insOff=0;
    }
}

void main()
{
    uint vindex = gl_GlobalInvocationID.x;
    //computeWorldAabb(vindex);

    vec4 quat = RigidBodyDatas.BodyDatas[vindex].quat;
    vec4 pos = RigidBodyDatas.BodyDatas[vindex].pos;

    vec4 min = localShapeAABB.bb[vindex].min;
    vec4 max = localShapeAABB.bb[vindex].max;
    outCube(min.xyz,max.xyz,pos,quat,vindex);
    computeWorldAabb(min.xyz,max.xyz,pos,quat,vindex);
}
